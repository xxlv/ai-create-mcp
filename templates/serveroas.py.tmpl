# Generated code - DO NOT EDIT
import asyncio
import aiohttp
import json
from typing import List, Dict, Optional
from mcp.server.models import InitializationOptions
import mcp.types as types
from mcp.server import NotificationOptions, Server
from pydantic import AnyUrl
import mcp.server.stdio
import random
import argparse

# Server state
state: dict[str, str] = {}

server = Server("{{.ServerName}}")
TOKEN=""
BASE_URLs = [
{{- range $i, $url := .Endpoints -}}
    "{{$url}}"{{if not $i}},{{end}}
{{- end -}}
]
{{if .Resources}}
@server.list_resources()
async def handle_list_resources() -> list[types.Resource]:
    return [
        {{range .Resources}}
        types.Resource(
            uri=AnyUrl("{{.URI}}"),
            name="{{.Name}}",
            description="""{{.Description}}""",
            mimeType="{{.MimeType}}",
        ),
        {{end}}
    ]

@server.read_resource()
async def handle_read_resource(uri: AnyUrl) -> str:
    if uri.scheme != "note":
        raise ValueError(f"Unsupported URI scheme: {uri.scheme}")
    name = uri.path.lstrip("/")
    return state.get(name, "")
{{end}}

{{if .Prompts}}
@server.list_prompts()
async def handle_list_prompts() -> list[types.Prompt]:
    return [
        {{range .Prompts}}
        types.Prompt(
            name="{{.Name}}",
            description="""{{.Description}}""",
            arguments=[
                {{range .Arguments}}
                types.PromptArgument(
                    name="{{.Name}}",
                    description="""{{.Description}}""",
                    required={{capitalizeBool .Required}},
                ),
                {{end}}
            ],
        ),
        {{end}}
    ]


{{if .Tools}}
@server.list_tools()
async def handle_list_tools() -> list[types.Tool]:
    return [
        {{range .Tools}}
        types.Tool(
            name="{{.Name}}",
            description="""{{.Description}}""",
            inputSchema={
                "type": "object",
                "properties": {
                    {{range .Arguments}}
                    "{{.Name}}": {"type": "string"},
                    {{end}}
                },
                "required": [
                    {{range .Arguments}}
                    {{if .Required}}"{{.Name}}",{{end}}
                    {{end}}
                ],
            },
        ),
        {{end}}
    ]

@server.call_tool()
async def handle_call_tool(name: str, arguments: Optional[Dict]) -> List[types.TextContent]:
    if not arguments:
        raise ValueError("Missing arguments")
    async with aiohttp.ClientSession() as session:
        {{range .Tools}}
        if name == "{{.Name}}":
            # Validate arguments
            {{range .Arguments}}
            {{.Name}} = arguments.get("{{.Name}}")
            if {{if .Required}}not {{.Name}}{{else}}False{{end}}:
                raise ValueError("Missing required argument: {{.Name}}")
            {{end}}
            # Prepare request parameters
            params = {}
            headers = {"Content-Type": "application/json"}

            headers.update({"Authorization": f"Bearer {TOKEN}"})

            url = f"{random.choice(BASE_URLs)}{{.Path}}"
            method = "{{.Method}}".lower()
            # Add query parameters (for GET requests)
            {{range .Arguments}}
            {{if .Required}}
            params["{{.Name}}"] = {{.Name}}
            {{end}}
            {{end}}
            # Prepare request body (for POST/PUT/PATCH)
            body = {}
            {{if eq .Method "POST" "PUT" "PATCH"}}
            {{range .Arguments}}
            body["{{.Name}}"] = {{.Name}}
            {{end}}
            {{end}}
            try:
                # Make HTTP request
                if method == "get":
                    async with session.get(url, params=params, headers=headers) as response:
                        result = await response.text()
                elif method == "post":
                    async with session.post(url, json=body, headers=headers) as response:
                        result = await response.text()
                elif method == "put":
                    async with session.put(url, json=body, headers=headers) as response:
                        result = await response.text()
                elif method == "patch":
                    async with session.patch(url, json=body, headers=headers) as response:
                        result = await response.text()
                elif method == "delete":
                    async with session.delete(url, params=params, headers=headers) as response:
                        result = await response.text()
                else:
                    raise ValueError(f"Unsupported method: {method}")
                
                # Store arguments in state
                {{range .Arguments}}
                state["{{.Name}}"] = arguments.get("{{.Name}}", "")
                {{end}}
                await server.request_context.session.send_resource_list_changed()
                
                return [types.TextContent(type="text", text=result)]
            except Exception as e:
                raise ValueError(f"Request failed: {str(e)}")
        {{end}}
        raise ValueError(f"Unknown tool: {name}")
    {{end}}
{{end}}


async def main():
    parser = argparse.ArgumentParser(description='use token for OAS standard api.')
    parser.add_argument('--token', type=str, help='Authentication token',default="")

    args = parser.parse_args()
    global TOKEN 
    TOKEN = args.token

    async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):
        await server.run(
            read_stream,
            write_stream,
            InitializationOptions(
                server_name="{{.ServerName}}",
                server_version="{{.ServerVersion}}",
                capabilities=server.get_capabilities(
                    notification_options=NotificationOptions(),
                    experimental_capabilities={},
                ),
            ),
        )

if __name__ == "__main__":
    asyncio.run(main())